# 排序算法分析（算法的优劣由占用空间与花费时间共同决定）

## 选择排序

### 分析

最贴近人类思想的排序方式。依次找到子列表中最符合条件的数据放在应该被放置的位置上。

### 优化

问题: 在通常情况下，若定义一个新的数组，则要花费两倍的内存空间。优化算法，仅采用一个列表。

方法：使用交换的方法，将被选中的合适的的数据与它应该被放置的位置上的数据进行交换。

代价: 仅需一个列表，但是也多占用了一个数据的空间，用来存放交换时的临时变量，且在时间上花费更多（每次进行交换都要进行两次赋值操作）。

### 伪代码实现

#### 方法一

list = {Sue, Cora, Beth, Ann, June}

FOR i from 0 to list.length-2 DO

Find index of the smallest item in list[i..list.length-1]

IF index <> i THEN

list.swap (i, index)

END IF

END FOR 

#### 方法二

list = {Sue, Cora, Beth, Ann, June}

FOR i from 0 to list.length-2 DO

index = i

FOR j from i+1 to list.length-1 DO

IF list[j] < list[index] THEN index=j

END FOR …

END FOR 

#### 思考题

哪个更好？

## 冒泡排序（同理于“沉底”排序）

### 分析

每次都比较连续的两个字符串而达到排序整个列表的方法。灵感来源于水中气泡在不断上升的过程中逐渐增大。

### 排序方法

每次都将连续的两个数据进行比较，将更符合的数据置于后者，进行下一次比较，依次进行下去就能找到子序列中最适合的值。然后缩小序列不断重复。

### 伪代码

list = {Sue, Cora, Beth, Ann, June}

FOR i from 0 to list.length-2 DO

Find index of the smallest item in list[i..list.length-1]

IF index <> i THEN

list.swap (i, index)

END IF

END FOR

## 快速排序

### 分析（排序方法）

分堆的思想，每次都随机选择一个数，将比他大比他小分为两堆，然后再在两堆中进行递归，直到完成排序。

### 伪代码

# 查找算法分析

## 顺序查找

### 分析

依次检索每一个数据，直到查找到我们想要的数据。

### 优缺点

相比于二分查找，顺序查找不依赖于列表是否已经排序，故适用面更广，而且更容易写出代码，但是对于已经排序好的序列，耗时远远长于二分查找。

## 二分查找

### 分析

运用递归的方法，每次都将数据的中间值与我们想要的数据进行比较，从而知道我们想要的数据在哪个区间。

### 优点

每次都能将规模一分为二，相对于顺序查找，能更快地找到我们想要的数据。对于我们常用的数据，远远优越于顺序查找。

### 缺点

具有局限性，仅适用于已经排序完成的序列，而有时排序所需的时间非常长，所以甚至不如直接顺序查找。

### 伪代码
