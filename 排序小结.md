# 插入排序与冒泡排序与选择排序与桶排序的算法分析（带实例）
## 冒泡排序
### 简介
冒泡排序（Bubble Sort，台湾译为：泡沫排序或气泡排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们
交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶
端。
### 步骤
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较
### 实例分析
为了方便分析，我们就采用作业10里面的数据作为分析的案例，这样更加直观。<br/>
先上代码<br/>
#include <stdio.h> <br/>
int main() { <br/>
int a[6] = {0} ; <br/>
for(int i = 0;i < 6;++i){ <br/>
scanf("%d",&a[i]); <br/>
} <br/>
for(int j = 0;j < 6;++j){ <br/>
for(int k = 0;k < 6 - j - 1;++k){ <br/>
if(a[k] > a[k + 1]){ <br/>
int c = a[k]; <br/>
a[k] = a[k + 1]; <br/>
a[k + 1] = c; <br/>
}<br/>
}<br/>
}<br/>
for(int i = 0;i < 6;++i){ <br/>
printf("%d\t",a[i]); <br/>
}<br/>
} <br/>
分析一下我们写的代码，首先第一部当然是将数据存进数组，这样才方便我们进行排序。<br/>
之后我们进行了两层循环，这也是冒泡排序的核心。在每一次进行第一层循环的过程中，我们都会将剩下的数中的最大的数像泡泡一样上浮到子数组的最后一个数，这样就相当于依次找到剩下的数中的最大的数，整个循环结束后，我们就实现了排序。
![](https://img-blog.csdn.net/20160921091654436)
冒泡排序效果概念图
## 插入排序
### 简介
插入排序（Insertion Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位
置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最
新元素提供插入空间。
### 步骤
1. 从第一个元素开始，该元素可以认为已经被排序
2. 取出下一个元素，在已经排序的元素序列中从后向前扫描
3. 如果该元素（已排序）大于新元素，将该元素移到下一位置
4. 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
5. 将新元素插入到该位置中
6. 重复步骤2
### 分析
为了更直观的比较两者的异同点，与冒泡排序相同，我们在分析插入排序时，也用到相同的数据，即这次作业中的第一题。<br/>
放上代码<br/>
#include <stdio.h> <br/>
int main() { <br/>
int a[6] = {0} ; <br/>
for(int i = 0;i < 6;++i){ <br/>
scanf("%d",&a[i]); <br/>
} <br/>
int i,j;<br/>
int temp;<br/>
for (i=1;i<6;i++)<br/>
{<br/>
temp = a[i];<br/>
j=i-1;<br/>
while (j > -1 && temp < a[j])<br/>
{<br/>
a[j + 1]= a[j];<br/>
j--;<br/>
}<br/>
a[j + 1] = temp;<br/>
}<br/>
}<br/>
for(int i = 0;i < 6;++i){ <br/>
printf("%d\t",a[i]); <br/>
}<br/>
} <br/>
在《算法导论》这本书上，讲到插入排序时，他做了一个生动的比喻，即将这样的一个排序过程比作起扑克牌整理手牌，一张一张的整理。每次拿到一个新的数之后
，我们就将它和前面的数进行比较，很容易知道的是，前面的数相当于子项目，已经完全排序好了，所以我们就近比较，若满足要求，就不用进行下一次比较，
但若不满足，就再向前比较，就像整理手牌从右到左的顺序一样，直到找到新数据该存在的位置。这样一套循环之后，我们的数据也就整理好了。
## 选择排序
### 简介
选择排序(Selection sort)是一种简单直观的排序算法。它的工作原理如下。首先在未排序序列中找到最小元素，存放到排序序列的起始位置，然后，再从剩余未排序元
素中继续寻找最小元素，然后放到排序序列末尾。以此类推，直到所有元素均排序完毕。
### 步骤
1. 在未排序序列中找到最小元素
2. 用方法将其存放到排序序列的起始位置
3. 从剩余未排序元素中继续寻找最小元素，然后放到排序序列末尾
4. 以此类推直到所有元素均排序完毕。
### 分析
为了更直观的比较两者的异同点，与冒泡排序相同，我们在分析选择排序时，也用到相同的数据，即这次作业中的第一题。<br/>
放上代码<br/>
#include <stdio.h> <br/>
int main() { <br/>
int a[6] = {0} ; <br/>
for(int i = 0;i < 6;++i){ <br/>
scanf("%d",&a[i]); <br/>
} <br/>
int i,j,min;<br/>
for(i = 0; i < 6; i++)<br/>
{<br/>
min = i;<br/>
for (j = i + 1; j < 6; j++) {<br/>
if (a[j] < a[min]) {<br/>
min = j;<br/>
}<br/>
}<br/>
if (min != i) {<br/>
a[i] = a[min];<br/>
} <br/>
}<br/>
}<br/>
正常来说，选择排序是最容易想到的排序算法，因为他和我们人类的思考方式差不多，一个又一个的找到最小的数，第二小的数.....并将它们依次放在第一个，第二个，
第三个.....位置上,如此一来，我们就很容易将一组数据排序好了。判断的方式是选择排序的核心，我们将记录下来的子序列中最小值的角标与i对比，若不相同就交换
他们，这样就很巧妙地交换了两者的位置。
![](https://img-blog.csdn.net/20160921091628124)
选择排序效果概念图
## 桶排序
### 简介
桶排序是另外一种以O(n)或者接近O(n)的复杂度排序的算法.它假设输入的待排序元素是等可能的落在等间隔的值区间内.一个长度为N的数组使用桶排序, 需要长度
为N的辅助数组. 等间隔的区间称为桶, 每个桶内落在该区间的元素. 桶排序是基数排序的一种归纳结果。
算法的主要思想: 待排序数组A[1...n]内的元素是随机分布在[0,1)区间内的的浮点数.辅助排序数组B[0....n-1]的每一个元素都连接一个链表.将A内每个元素乘以
N(数组规模)取底,并以此为索引插入(插入排序)数组B的对应位置的连表中. 最后将所有的链表依次连接起来就是排序结果.
### 步骤     
1. 设置一个定量的数组当作空桶子。
2. 寻访序列，并且把项目一个一个放到对应的桶子去。
3. 对每个不是空的桶子进行排序。
4. 从不是空的桶子里把项目再放回原来的序列中。
### 分析
我们大部分人是从期中考试的第一题认识到桶排序，这里就采用那道题为案例进行分析
代码如下<br/>
#include <stdio.h><br/>
int main(void) {<br/>
	int n;<br/>
	scanf("%d", &n);<br/>
	int num, sum = 0;<br/>
	int bucket[10] = { 0 };<br/>
	while (n--) {<br/>
		scanf("%d", &num);<br/>
		sum += num;<br/>
		bucket[num] += 1;<br/>
	}<br/>
	if (bucket[0] == 0 || sum == 0 || sum %3 != 0) {<br/>
		printf("no such number\n");<br/>
	}else{<br/>
		int i = 9;<br/>
		while (i) {<br/>
			while (bucket[i]--) {<br/>
				printf("%d", i);<br/>
			}<br/>
			i--;<br/>
		}<br/>
		while (bucket[0]--) {<br/>
			printf("%d", i);<br/>
		}<br/>
		printf("\n");<br/>
	}<br/>
	return 0;<br/>
}<br/>
正如老师分析题目时说的那样，桶排序，顾名思义，就是将不同种的数据装在不同的“桶”中，而相同的数据放在同一个桶中，然后我们想要排序数据就只需要对桶进行
排序，这样在按照顺序输出就得到了我们想要的排序。桶排序比较适用于需排列数据较多，而且重复度较高的数据处理。
## 比较
按照《算法导论》这本书上所说，前三者的平均时间复杂度其实是差不多的，但是却又各有优点。冒泡排序是最为简单的排序方式，很适合新手，实用性也很广，
但数据一多，处理起来就很慢；而插入排序，虽然在最坏情况下，和冒泡排序复杂程度差不多，但无论何时何种情况，他都优于冒泡排序，因此也是很实用的低级
排序方式，但是插入排序有很多种改版，比如加入二分法的插入排序，抑或是与归并排序相结合。这样就提高了插入排序的上限，进一步增强了他的处理数据能力；而选择
排序也是一个很简单的排序算法，解决我们身边的数据绰绰有余，而且在我看来也是最贴近我们人类思考方式的算法，实用性一样非常的高。桶排序的复杂性非常小，
所以十分高效，但是使用范围十分有限，但在那些情况下，用桶排序的优越性是不言而喻的。
## 总结
前三种排序方法都是比较基础的方法，在处理大量数据时，显得有点力不从心，但是他们极强的可读性以及简便性为我们的日常生活的数据处理提供了极大的便利
，而且他们的增强版也是我们的得力助手。所以认真学习并掌握其精髓是十分重要的！而桶排序虽然少见，却对于某一类数据的处理十分高效，所以我们也要熟练地掌握！
